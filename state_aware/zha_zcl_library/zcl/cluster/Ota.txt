class Ota(Cluster):
    ImageUpgradeStatus: Final = ImageUpgradeStatus
    UpgradeActivationPolicy: Final = UpgradeActivationPolicy
    UpgradeTimeoutPolicy: Final = UpgradeTimeoutPolicy
    ImageNotifyCommand: Final = ImageNotifyCommand
    QueryNextImageCommand: Final = QueryNextImageCommand
    ImageBlockCommand: Final = ImageBlockCommand
    ImagePageCommand: Final = ImagePageCommand
    ImageBlockResponseCommand: Final = ImageBlockResponseCommand

    cluster_id: Final[t.uint16_t] = 0x0019
    ep_attribute: Final = "ota"

    class AttributeDefs(BaseAttributeDefs):
        upgrade_server_id: Final = ZCLAttributeDef(
            id=0x0000, type=t.EUI64, access="r", mandatory=True
        )
        file_offset: Final = ZCLAttributeDef(id=0x0001, type=t.uint32_t, access="r")
        current_file_version: Final = ZCLAttributeDef(
            id=0x0002, type=t.uint32_t, access="r"
        )
        current_zigbee_stack_version: Final = ZCLAttributeDef(
            id=0x0003, type=t.uint16_t, access="r"
        )
        downloaded_file_version: Final = ZCLAttributeDef(
            id=0x0004, type=t.uint32_t, access="r"
        )
        downloaded_zigbee_stack_version: Final = ZCLAttributeDef(
            id=0x0005, type=t.uint16_t, access="r"
        )
        image_upgrade_status: Final = ZCLAttributeDef(
            id=0x0006, type=ImageUpgradeStatus, access="r", mandatory=True
        )
        manufacturer_id: Final = ZCLAttributeDef(id=0x0007, type=t.uint16_t, access="r")
        image_type_id: Final = ZCLAttributeDef(id=0x0008, type=t.uint16_t, access="r")
        minimum_block_req_delay: Final = ZCLAttributeDef(
            id=0x0009, type=t.uint16_t, access="r"
        )
        image_stamp: Final = ZCLAttributeDef(id=0x000A, type=t.uint32_t, access="r")
        upgrade_activation_policy: Final = ZCLAttributeDef(
            id=0x000B, type=UpgradeActivationPolicy, access="r"
        )
        upgrade_timeout_policy: Final = ZCLAttributeDef(
            id=0x000C, type=UpgradeTimeoutPolicy, access="r"
        )
        cluster_revision: Final = foundation.ZCL_CLUSTER_REVISION_ATTR
        reporting_status: Final = foundation.ZCL_REPORTING_STATUS_ATTR

    class ServerCommandDefs(BaseCommandDefs):
        query_next_image: Final = ZCLCommandDef(
            id=0x01, schema=QueryNextImageCommand, direction=Direction.Client_to_Server
        )
        image_block: Final = ZCLCommandDef(
            id=0x03, schema=ImageBlockCommand, direction=Direction.Client_to_Server
        )
        image_page: Final = ZCLCommandDef(
            id=0x04, schema=ImagePageCommand, direction=Direction.Client_to_Server
        )
        upgrade_end: Final = ZCLCommandDef(
            id=0x06,
            schema={
                "status": foundation.Status,
                "manufacturer_code": t.uint16_t,
                "image_type": t.uint16_t,
                "file_version": t.uint32_t,
            },
            direction=Direction.Client_to_Server,
        )
        query_specific_file: Final = ZCLCommandDef(
            id=0x08,
            schema={
                "request_node_addr": t.EUI64,
                "manufacturer_code": t.uint16_t,
                "image_type": t.uint16_t,
                "file_version": t.uint32_t,
                "current_zigbee_stack_version": t.uint16_t,
            },
            direction=Direction.Client_to_Server,
        )

    class ClientCommandDefs(BaseCommandDefs):
        image_notify: Final = ZCLCommandDef(
            id=0x00, schema=ImageNotifyCommand, direction=Direction.Client_to_Server
        )
        query_next_image_response: Final = ZCLCommandDef(
            id=0x02,
            schema={
                "status": foundation.Status,
                "manufacturer_code?": t.uint16_t,
                "image_type?": t.uint16_t,
                "file_version?": t.uint32_t,
                "image_size?": t.uint32_t,
            },
            direction=Direction.Server_to_Client,
        )
        image_block_response: Final = ZCLCommandDef(
            id=0x05,
            schema=ImageBlockResponseCommand,
            direction=Direction.Server_to_Client,
        )
        upgrade_end_response: Final = ZCLCommandDef(
            id=0x07,
            schema={
                "manufacturer_code": t.uint16_t,
                "image_type": t.uint16_t,
                "file_version": t.uint32_t,
                "current_time": t.UTCTime,
                "upgrade_time": t.UTCTime,
            },
            direction=Direction.Server_to_Client,
        )
        query_specific_file_response: Final = ZCLCommandDef(
            id=0x09,
            schema={
                "status": foundation.Status,
                "manufacturer_code?": t.uint16_t,
                "image_type?": t.uint16_t,
                "file_version?": t.uint32_t,
                "image_size?": t.uint32_t,
            },
            direction=Direction.Server_to_Client,
        )

    def handle_cluster_request(
        self,
        hdr: foundation.ZCLHeader,
        args: list[Any],
        *,
        dst_addressing: AddressingMode | None = None,
    ):
        # We don't want the cluster to do anything here because it would interfere with
        # the OTA manager
        device = self.endpoint.device
        if device.ota_in_progress:
            return

        if (
            hdr.direction == foundation.Direction.Client_to_Server
            and hdr.command_id == self.ServerCommandDefs.query_next_image.id
        ):
            self.create_catching_task(
                self._handle_query_next_image(hdr, args),
            )
        elif (
            hdr.direction == foundation.Direction.Client_to_Server
            and hdr.command_id == self.ServerCommandDefs.image_block.id
        ):
            self.create_catching_task(
                self._handle_image_block_req(hdr, args),
            )

    async def _handle_query_next_image(self, hdr, cmd):
        # Always send no image available response so that the device stops asking
        await self.query_next_image_response(
            foundation.Status.NO_IMAGE_AVAILABLE, tsn=hdr.tsn
        )

        device = self.endpoint.device
        images_result = await device.application.ota.get_ota_images(device, cmd)

        device.listener_event(
            "device_ota_image_query_result",
            images_result,
            cmd,
        )

    async def _handle_image_block_req(self, hdr, cmd):
        # Abort any running firmware update (i.e. the integration is reloaded midway)
        await self.image_block_response(foundation.Status.ABORT, tsn=hdr.tsn)